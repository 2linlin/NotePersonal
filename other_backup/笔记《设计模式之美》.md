## 1.单例模式

什么是单例模式：一个类只允许创建一个对象，这个就是单例模式。

### 单例模式有啥用？

#### 1.处理资源访问冲突

例如往文件打印日志的Logger类，很多地方会用到。在多线程同时访问的情况下，会有操作覆盖的问题。解决的思路有几个：

- 加锁。类级别的锁、分布式锁等等。
- 并发队列。比如Java中的BlockingQueue，多个线程同时往并发队列里写日志，一个单独的线程负责把并发队列中的数据写到日志文件。
- 单例模式。

#### 2.表示全局唯一类

从业务逻辑上，有些数据在系统中只应保存一份，如：配置信息类，唯一ID生成器等。

### 单例怎么实现？

实现时一般考虑几个方面：

- 构造函数要私有
- 对象创建时是否安全
- 要不要支持延迟加载
- getInstance()方法是否高效

#### 1.饿汉式

类加载的时候就创建好类了，但是不支持延迟加载。

```java
public class IdGenerator {
    private AtomicLong id = AtomicLong(0);
	private static final IdGenerator idGenerator = new IdGenerator();  
    
    private IdGenerator() {}
    public static IdGenerator getInstance() {
        return idGenerator;
    }
    
    public long getId() {
        return id.incrementAngGet();
    }
}
```

有人觉得饿汉式不好，觉得如果初始化慢，或者实例占用资源多，提前初始化是浪费资源。

但是个人觉得：

- 就是因为初始化慢，才要在一开始就做好初始化工作，避免运行程序时导致性能问题。
- 就是占用资源多，所以开始就要提前占用资源，能够提早把问题暴露出来，避免到时候突然占用导致系统崩溃

所以饿汉式也不是那么不堪。用不用饿汉式，只是一个取舍的问题。

#### 2.懒汉式

支持延迟加载，但是getInstance()反复获取锁释放锁，效率不高。

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private static IdGenerator idGenerator;

    private IdGenerator() {}
    public static synchronized IdGenerator getInstance() {
        if (idGenerator == null) {
            idGenerator = new IdGenerator();
        }
        return idGenerator;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

懒汉式的缺点是，加了一把大锁。如果频繁调用，那频繁加锁释放锁还是挺浪费性能的。

#### 3.双检锁

支持延迟加载，并且解决了懒汉式getInstance()方法反复获取锁释放锁效率低的问题。

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private static IdGenerator idGenerator;

    private IdGenerator() {}
    public static IdGenerator getInstance() {
        if (idGenerator == null) {
            synchronized(IdGenerator.class) {
                if (idGenerator == null) {
                    idGenerator = new IdGenerator();
                }
            }
        }
        return idGenerator;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

在低版本的Java中，由于对象的new操作和初始化操作不是原子性的，为了避免对象还没初始化，就被其他线程拿去用了，需要在idGenerator变量前面加上volatile关键字，禁止指令重排序。

在高版本的Java中，对象的new操作和初始化操作不是原子性这个问题已经解决，所以无需再加volatile关键字。

#### 4.内部静态类

支持延迟加载，getInstance()方法效率也高。实现比双检锁简单。

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);

    private IdGenerator() {}
    public static IdGenerator getInstance() {
        return InstanceHolder.idGenerator;
    }

    private static class InstanceHolder {
        private static final IdGenerator idGenerator = new IdGenerator();
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

#### 5.枚举

最简单的实现方式，运用了Java的枚举特性：构造方法默认私有，可以用类直接引用枚举。

```java
public enum IdGeneratorEnum {
    INSTANCE;

    private AtomicLong id = new AtomicLong(0);

    public long getId() {
        return id.incrementAndGet();
    }
}
```

### 单例模式有什么问题？

待补充，参见42。

### 单例模式有啥替代解决方案？

待补充，参见42。

### 单例模式扩展讨论

待补充，参见43。

如何理解单例的唯一性？

如何实现线程唯一的单例？

如何实现集群环境下的单例？

如何实现一个多例模式？

## 2.工厂模式

















