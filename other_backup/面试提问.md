#### 1.单核机器使用多线程是否有意义？

有意义，例如I/O密集型的情况下。

#### 2.finally里面的字句一定会被执行吗？

后台线程不会执行。

#### 3.@Resource和@Autowired区别

前者为JSR的标准，后者为Spring特有。前者默认byName查找，找不到时回退为byType。后者默认byType，找不到时报错，找到多个时需要用@Qualifier注明，否则报错。

（1）处理这2个注解的BeanPostProcessor不一样

CommonAnnotationBeanPostProcessor是处理@ReSource注解的

AutoWiredAnnotationBeanPostProcessor是处理@AutoWired注解的

（2）@Autowired只按照byType 注入；@Resource默认按byName自动注入，也提供按照byType 注入；

（3）属性：@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。

@Resource装配顺序

　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常

　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常

　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常

　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；

推荐使用@Resource注解在字段上，这样就不用写setter方法了.并且这个注解是属于J2EE的，减少了与Spring的耦合,这样代码看起就比较优雅 。

#### 4.Spring有几种注入方式

构造方法注入。Setter注入。接口注入（个人理解这个相当于是吧Setter()方法抽出来作为一个接口而已）。

Spring的[文档](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-collaborators)上说：

> DI exists in two major variants, Constructor-based dependency
> injection and Setter-based dependency injection.

我的理解是，接口注入其实也是通过setter注入来实现的：

```java
interface InjectPerson {
    public void injectHere(Person p);
}

class Company implements InjectPerson {
   Person injectedPerson; 

   public void injectHere(Person p) {
       this.injectedPerson = p;
   }
}
```

